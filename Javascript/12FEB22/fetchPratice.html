<!-- @format -->

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      // * fetch : XMLHttpRequest 객체와 마찬가지로 HTTP 요청 전송 기능을 제공하는 클라이언트 사이드 Web API다. fetch 함수는 XMLHttpRequest 객체보다 사용법이 간단하고 프로미스를 지원하기 떄문에 비동기 처리를 위한 콜백 패턴의 단점에서 자유롭다. 특히 최근에 추가된 Web API로서 인터넷 익스플로러를 제외한 대부분의 모던 브라우저에서 제공함

      // fetch 함수는 HTTP 응답을 나타내는 Response 객체를 래핑한 Promise 객체를 반환한다.

      // let promise = fetch(url, [options])
      // options에 아무것도 넘기지 않으면 요청은 GET 메서드로 진행되어 url로부터 콘텐츠가 다운로드 됩니다.

      // fetch('https://jsonplaceholder.typicode.com/todos/1').then((response) =>
      //   console.log(response)
      // );

      // response 에는 프라미스를 기반으로 하는 다양한 메서드가 있습니다. 이 메서드들을 사용하면 다양한 형태의 응답 본문을 처리할 수 있습니다.

      // response.text() – 응답을 읽고 텍스트를 반환합니다,
      // response.json() – 응답을 JSON 형태로 파싱합니다,
      // response.formData() – 응답을 FormData 객체 형태로 반환합니다. FormData에 대한 자세한 내용은 다음 챕터에서 다루겠습니다.
      // response.blob() – 응답을 Blob(타입이 있는 바이너리 데이터) 형태로 반환합니다.
      // response.arrayBuffer() – 응답을 ArrayBuffer(바이너리 데이터를 로우 레벨 형식으로 표현한 것) 형태로 반환합니다.
      // 이 외에도 response.body가 있는데, ReadableStream 객체인 response.body를 사용하면 응답 본문을 청크 단위로 읽을 수 있습니다. 자세한 용례는 곧 살펴보겠습니다.

      fetch('https://jsonplaceholder.typicode.com/posts/1')
        .then((response) => response.json())
        .then((data) => {
          console.log(data);
          // body: 'quia et suscipit\nsuscipit recusandae consequuntur expedita et cum\nreprehenderit molestiae ut ut quas totam\nnostrum rerum est autem sunt rem eveniet architecto';
          // id: 1;
          // title: 'sunt aut facere repellat provident occaecati excepturi optio reprehenderit';
          // userId: 1;
          console.log(data.title);
          // sunt aut facere repellat provident occaecati excepturi optio reprehenderit
        });
    </script>
  </body>
</html>
